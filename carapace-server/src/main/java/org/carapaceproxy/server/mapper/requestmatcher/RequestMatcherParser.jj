options {
    STATIC = false;
    IGNORE_CASE = true;
    UNICODE_INPUT = true;    
}

PARSER_BEGIN(RequestMatcher)

package org.carapaceproxy.server.mapper.requestmatcher;

import io.netty.handler.codec.http.HttpRequest;
import java.io.StringReader;
import java.util.regex.Pattern;
import org.carapaceproxy.server.RequestHandler;

/**
 * Criteria to apply a route to a request
 */
public class RequestMatcher {           
    private HttpRequest request;
    private String matchingCondition;

    public RequestMatcher(HttpRequest request, String matchingCondition) {
        this(new StringReader(matchingCondition));
        this.matchingCondition = matchingCondition;
        this.request = request;
    }

    @Override
    public String toString() {
        return "RequestMatcher{" + "request=" + request + ", matchingCondition=" + matchingCondition + '}';
    }
}


PARSER_END(RequestMatcher)

SKIP :
{
    " " |
    "\t" |
    "\n" |
    "\r"
}

TOKEN :
{
    < ALL: "all" > |
    < REGEXP_DEF: "regexp" > |
    < AND: "and" > |
    < OR: "or" > |
    < NOT: "not" > |
    < HTTPS: "https" > |
    < O_BRACKET: "(" > |
    < C_BRACKET: ")" > |
    < REGEXP: "'" (~["'"])* "'" >
}

/* Main method to call to check request matching over a matchingCondition:
    *   - all
    *   - https
    *   - regexp '.*index.*'
    *   - regexp '.*index.*' and not https
    */
boolean matches() :
{
    String regexp;
    boolean cond;
    boolean expr;    
}
{
    <ALL> { return true; } |
    cond = expression() { return cond; } |
    (
        <REGEXP_DEF> regexp = <REGEXP>.image
        {
            regexp = regexp.substring(1, regexp.length() - 1);
            cond = Pattern.compile(regexp).matcher(this.request.uri()).matches();
        }
        (
            <AND> expr = expression() { cond &= expr; } |
            <OR> expr = expression() { cond |= expr; }
        )?
        { return cond; }
    )
}

boolean expression() :
{
    boolean term;    
}
{
    term = term()
    (
        <OR> { term |= term(); }
    )*
    { return term; }
}

boolean term() :
{
    boolean factor;    
}
{
    factor = factor()
    (
        <AND> { factor &= factor(); }
    )*
    { return factor; }
}

boolean factor() :
{
    boolean value;
}
{
    value = value() { return value; } |
    <NOT> value = factor() { return !value; } |
    (
        <O_BRACKET> value = expression() <C_BRACKET>
    )
    { return value; }
}

boolean value() :
{}
{
    <HTTPS> { return RequestHandler.PROTO_HTTPS.equals(this.request.headers().get(RequestHandler.HEADER_X_FORWARDED_PROTO, "")); }
}